source AEaddRampControl;
source houdiniEngineAssetInput;
source houdiniEngineHistoryAsset;
source houdiniEngineBakeAsset;

global int $gAttributeEditorTemplateLabelWidthCustom = 147;

global proc AEhoudiniAssetTemplate_fileAttributeBrowse(string $plug) {
    string $categories[] = `addAttr -q -category ($plug)`;

    string $fileFilter = "*.*(*.*)";
    for($category in $categories)
    {
        string $prefix = "hapiParmFile_filter";
        if(startsWith($category, $prefix))
        {
            $fileFilter = stringRemovePrefix($category, $prefix);
            break;
        }
    }

    int $fileMode = 4;
    if(stringArrayFind("hapiParmFile_read", 0, $categories) != -1)
        $fileMode = 4;
    else if(stringArrayFind("hapiParmFile_write", 0, $categories) != -1)
        $fileMode = 0;
    if(stringArrayFind("hapiParmFile_directory", 0, $categories) != -1) {
        $fileMode = 3;
        $fileFilter = "";
    }

    string $fileDialogResults[] = `fileDialog2
        -caption $plug
        -fileFilter $fileFilter
        -fileMode $fileMode
        -okCaption "Select"`;
    if(size($fileDialogResults))
    {
        setAttr -type "string"
            $plug
            $fileDialogResults[0];
    }
}

global proc AEhoudiniAssetTemplate_setComponentSelection(string $plug, string $componentType) {
    string $components = `python("from houdiniEngineSelection import get_selected_components; " + 
                                 "get_selected_components(\'" + $componentType + "\')")`;

    setAttr -type "string" $plug $components;
}

global proc AEhoudiniAssetTemplate_textEdit(string $plug, string $title, int $editable) {
    string $window = stringArrayToString(stringToStringArray("houdiniEngine_textEdit_" + $title, "|."), "_");

    if(`window -exists $window`) {
        showWindow $window;
        return;
    }

    window
        -title $title
        $window;

    string $mainLayout = `formLayout`;

    string $currentText = `getAttr $plug`;
    string $scrollField = `scrollField -text $currentText`;

    scrollField -e
        -enterCommand ("setAttr -type \"string\" " + $plug + " "
                + "`scrollField -q -text " + $scrollField + "`")
        $scrollField;

    string $buttonLayout = `formLayout`;

    button
        -label "Apply"
        -enable $editable
        -command ("setAttr -type \"string\" " + $plug + " "
                + "`scrollField -q -text " + $scrollField + "`" + "; evalDeferred \"deleteUI " + $window + "\"")
        applyButton;
    button
        -label "Cancel"
        -command ("evalDeferred \"deleteUI " + $window + "\"")
        cancelButton;

    setParent ..;

    formLayout -e
        -attachNone applyButton "top"
        -attachForm applyButton "left" 5
        -attachForm applyButton "bottom" 5
        -attachPosition applyButton "right" 1 50

        -attachNone cancelButton "top"
        -attachPosition cancelButton "left" 1 50
        -attachForm cancelButton "bottom" 5
        -attachForm cancelButton "right" 5

        $buttonLayout;

    setParent ..;

    formLayout -e
        -attachForm $scrollField "top" 5
        -attachForm $scrollField "left" 5
        -attachControl $scrollField "bottom" 5 $buttonLayout
        -attachForm $scrollField "right" 5

        -attachForm $buttonLayout "left" 5
        -attachForm $buttonLayout "bottom" 5
        -attachForm $buttonLayout "right" 5
        $mainLayout;

    showWindow $window;
}

proc createInputWidget(string $attr, string $label) {
    string $inputLayout = $attr + "Layout";
    $inputLayout = substituteAllString($inputLayout, "|", "_");
    $inputLayout = substituteAllString($inputLayout, ".", "_");
    $inputLayout = substituteAllString($inputLayout, "[", "_");
    $inputLayout = substituteAllString($inputLayout, "]", "_");
    string $inputLayoutFull = `setParent -q` + "|" + $inputLayout;

    //text -align left -label $label;
    int $isEnabled =  (`getAttr -lock $attr` == 1) ? 0 : 1 ;

    rowLayout
        -numberOfColumns 2
        -adjustableColumn 1
        -columnAttach 1 "both" 0
        -columnAttach 2 "left" 0
        $inputLayout;

        string $inputTextFieldFull = ($inputLayoutFull + "|inputTextField");
        textFieldGrp
            -enable $isEnabled
            -label $label
            -changeCommand ("AEhoudiniAssetSetInputToText \"" + $inputTextFieldFull + "\" \"" 
                + $attr + "\"") 
            "inputTextField";

        iconTextButton
            -enable $isEnabled 
            -style "iconOnly" -image "object_NEX.png"
            -label "Set to Selection" 
            -h 20 -w 20
            -annotation "Set input field to selected object."
            -command ("AEhoudiniAssetSetInputToSelection \"" + $attr + "\"");

    setParent ..;

    scriptJob
        -parent $inputLayoutFull
        -replacePrevious
        -attributeChange $attr ("AEhoudiniAssetUpdateInput \"" + $inputLayoutFull + "\" \"" 
            + $attr + "\"");

    AEhoudiniAssetUpdateInput $inputLayoutFull $attr;
}

proc createButtonParm(string $attr, string $label, int $enable, string $annotation) {
    global int $gAttributeEditorTemplateLabelWidthCustom;
    
    columnLayout
        -height 27
        -columnAttach "both" $gAttributeEditorTemplateLabelWidthCustom;
        
        button
            -enable $enable
            -height 20 -width 148
            -label $label 
            -command ("setAttr " + $attr + " 1")
            -annotation $annotation;
        
        setParent ..;
}

proc createFileInputStringParm(string $attr, string $label, int $enable, string $annotation) {
    string $text = `getAttr $attr`;

    rowLayout
        -numberOfColumns 2
        -adjustableColumn 1
        -columnAttach 1 "both" 0
        -columnAttach 2 "left" 0;

        string $textField = `textFieldGrp
            -enable $enable
            -label $label
            -text $text
            -annotation $annotation`;

        string $iconTextButton = `iconTextButton 
            -enable $enable
            -height 20 -width 20
            -style "iconOnly" 
            -image "fileOpen.png"
            -label "Open File" 
            -annotation "Open file browser."`;

        setParent ..;

    textFieldGrp -e
        -changeCommand ("setAttr -type \"string\" \"" + $attr + "\" `textFieldGrp -q -text " + $textField + "`")
        $textField;

    iconTextButton -e 
        -command ("AEhoudiniAssetTemplate_fileAttributeBrowse \"" + $attr + "\"")
        $iconTextButton;

    scriptJob
        -parent $textField
        -attributeChange $attr ("textFieldGrp -e -text `getAttr " + $attr + "` \"" + $textField + "\"");
}

proc createPrimSelectionParm(string $attr, string $label, int $enable, string $annotation, string $selectionType, int $selectionIndex) {
    string $selectionIcons[] = {
        "UVTkVertex.png",
        "UVTkFace.png", 
        "UVTkEdge.png", 
        "UVTkUV.png"};
    string $selectionHelp[] = {
        "Set input field to selected vertices.",
        "Set input field to selected faces.",
        "Set input field to selected edges.",
        "Set input field to selected uvs."};

    string $text = `getAttr $attr`;

    rowLayout
        -numberOfColumns 2
        -adjustableColumn 1
        -columnAttach 1 "both" 0
        -columnAttach 2 "left" 0;

        string $textField = `textFieldGrp
            -enable $enable
            -label $label
            -text $text
            -annotation $annotation`;

        string $iconTextButton = `iconTextButton 
            -enable $enable
            -height 20 -width 20
            -style "iconOnly" 
            -image ($selectionIcons[$selectionIndex])
            -label "Set to Selection" 
            -annotation ($selectionHelp[$selectionIndex])
            -command ("AEhoudiniAssetTemplate_setComponentSelection \"" + $attr + "\" \"" + $selectionType + "\"")`;

        setParent ..;

    // Value changed in UI callback. Update engine.
    textFieldGrp -e
        -changeCommand ("setAttr -type \"string\" \"" + $attr + "\" `textFieldGrp -q -text " + $textField + "`")
        $textField;

    // Value changed in engine callback. Update UI.
    scriptJob
        -parent $textField
        -attributeChange $attr ("textFieldGrp -e -text `getAttr " + $attr + "` \"" + $textField + "\"");
}

proc createStringParm(string $attr, string $attrName, string $label, int $enable, string $annotation, string $parmName, string $selectionType) {
    string $textTypes[] = {
        "__info__", 
        "__warning__", 
        "__error__"};
    string $textIcons[] = {
        "info.png", 
        "warningIcon.svg", 
        "error.png", 
        "greasePencilPencil.png"};

    int $iconIndex = 3;
    int $isEditable = 1;
    string $labelButton = "Edit";
    string $annotationButton = "Edit text field.";

    if ($selectionType == "info") {
        $iconIndex = 0;
        $isEditable = 0;
        $labelButton = "Read";
        $annotationButton = "Open text field window.";
    }

    /*
    for ($i = 0; $i < size($textTypes); $i++) {
        if (endsWith($parmName, $textTypes[$i])) {
            $iconIndex = $i;
            $isEditable = 0;
            $labelButton = "Read";
            $annotationButton = "Open text field window.";
            break;
        }
    }*/

    string $text = `getAttr $attr`;

    rowLayout
        -numberOfColumns 2
        -adjustableColumn 1
        -columnAttach 1 "both" 0
        -columnAttach 2 "left" 0;

        string $textField = `textFieldGrp
            -enable $enable
            -editable $isEditable
            -label $label
            -text $text
            -annotation $annotation`;

        string $iconTextButton = `iconTextButton 
            -enable $enable
            -height 20 -width 20
            -style "iconOnly" 
            -image ($textIcons[$iconIndex])
            -label $labelButton
            -annotation $annotationButton
            -command ("AEhoudiniAssetTemplate_textEdit \"" + $attr + "\" \"" + $attrName + "\" " + $isEditable)`;

        setParent ..;

    // Value changed in UI callback. Update engine.
    textFieldGrp -e
        -changeCommand ("setAttr -type \"string\" \"" + $attr + "\" `textFieldGrp -q -text " + $textField + "`")
        $textField;

    // Value changed in engine callback. Update UI.
    scriptJob
        -parent $textField
        -attributeChange $attr ("textFieldGrp -e -text `getAttr " + $attr + "` \"" + $textField + "\"");
}

proc createMultiParm(string $attr, string $child, string $suffix, string $fullAttr, string $nodeName, string $annotation) {
    string $multiAttr = substring($child, 1, size($child) - size($suffix));
    string $multiFullAttr = $fullAttr + "." + $multiAttr;
    string $multiFullName = substring($attr, 1, size($attr) - size($suffix)) + "[" + 0 + "]";

    int $isParentEnabled = 1;
    if (attributeExists($multiAttr, $nodeName)) {
        string $multiChildren[] = `attributeQuery -node $nodeName -listChildren $multiAttr`;
        for($multiChild in $multiChildren) {
            int $isParentEnabled = (`getAttr -lock ($multiFullName + "." + $multiChild)` == 1) ? 0 : 1 ;
            if ($isParentEnabled == 0) {
                break;
            }
        }
    }

    columnLayout
        -adjustableColumn true
        -rowSpacing 2;

        string $parent = `setParent -q`;

        // attributeEditorTemplate messes up layout, so pop out of it temporarily
        setUITemplate -popTemplate;

        rowLayout
            -numberOfColumns 4
            -columnAttach 1 "both" 0
            -columnAttach 2 "both" 2
            -columnAttach 3 "both" 2
            -columnAttach 4 "both" 2;

            attrControlGrp
                -enable $isParentEnabled
                -attribute $attr
                -annotation $annotation
                // Forcing evaluation here ensures the element attribute is
                // created before houdiniAssetAdjustMulti() is executed. This
                // prevents the UI from a completel rebuild when
                // houdiniAssetAdjustMulti() accesses the new element.
                -changeCommand ("dgeval " + $nodeName + ".output; houdiniAssetAdjustMulti \\\"" + $parent + "\\\" \\\"" + $nodeName + "\\\" \\\"" + $multiAttr + "\\\" \\\"" + $multiFullAttr + "\\\"");           

            button
                -enable $isParentEnabled
                -label "+"
                -height 20 -width 20
                -annotation "Add multiparm element."
                -command ("setAttr " + $attr + " (`getAttr " + $attr + "` + 1)");
            
            button
                -enable $isParentEnabled
                -label "-"
                -height 20 -width 20
                -annotation "Remove multiparm element."
                -command ("setAttr " + $attr + " (`getAttr " + $attr + "` - 1)");

            button
                -enable $isParentEnabled
                -label "Clear"
                -height 20 -width 40
                -annotation "Remove all multiparm elements."
                -command ("setAttr " + $attr + " 0");

            setParent ..;

        setUITemplate -pushTemplate attributeEditorTemplate;

        houdiniAssetAdjustMulti($parent, $nodeName, $multiAttr, $multiFullAttr);

        setParent ..;
}

proc createRampParm(string $attr, string $label) {
    string $parent = `setParent -q`;
    rowLayout
        -numberOfColumns 2
        -columnWidth1 147
        -adjustableColumn 2;
        
        text 
            -label $label
            -align "right";
        setParent ..;
    setParent $parent;

    columnLayout
        -adjustableColumn true
        -columnAttach "left" 22;

        AEmakeLargeRamp($attr, 0, 0, 0, 0, 0);

        // Workaround layout issue in AE where AEmakeLargeRamp doesn't
        // correctly restore parent.
        setParent ..;
    setParent $parent;
}

proc buildAttrTree(string $nodeName, string $attr, string $fullAttr)
{
    string $fullAttrName = $nodeName + "." + $fullAttr;

    // Using for-in loop with the attributeQuery result directly crashes Maya.
    // This is most likely a MEL bug. Workaround it by first storing the result
    // into a string array.
    //for($child in `attributeQuery -node $nodeName -listChildren $attr`)

    string $children[] = `attributeQuery -node $nodeName -listChildren $attr`;
    for($child in $children) {
        // Fix for Maya fatal error from compound attributes without children 
        if (`match "__dummy__" $child` == "__dummy__") {
            continue;
        }

        if ( `match "sepparm" $child` == "sepparm") {
            separator -height 12 -style "in";
            continue;
        } else if ( `match "spacer" $child` == "spacer") {
            separator -height 12 -style "none" -backgroundColor 0.285 0.285 0.285;
            continue;
        }
        
        string $plug = $fullAttrName + "." + $child;
        
        // get info about parm
        string $type = `getAttr -type $plug`;
        
        int $isFolder = endsWith($child, "__folder");
        int $isCompound = ($type == "TdataCompound");
        int $isMulti = `attributeQuery -node $nodeName -multi $child`;
        int $isRamp = endsWith($child, "__ramp");

        string $multiparm_suffix = "__multiSize";
        int $isMultiSize = endsWith($child, $multiparm_suffix);

        int $isSimpleAttribute = `attrControlGrp -q -handlesAttribute $plug` && !$isMultiSize && !$isFolder;
        
        int $isEnabled =  (`getAttr -lock $plug` == 1) ? 0 : 1 ;

        string $parmName = stringRemovePrefix($child, "houdiniAssetParm_");
        string $parmHelp = `houdiniAsset -parmHelp $parmName $nodeName`;
        string $niceName = `attributeQuery -node $nodeName -niceName $child`;
        
        string $categories[] = `addAttr -q -category ($plug)`;

        if(endsWith($child, "__button")) {
            createButtonParm($plug, $niceName, $isEnabled, $parmHelp);
        
        } else if(endsWith($child, "__node")) {
            createInputWidget($plug, $niceName);
        
        } else if($isSimpleAttribute) {
            if (`addAttr -q -usedAsFilename $plug`) {   
                createFileInputStringParm($plug, $niceName, $isEnabled, $parmHelp);
            
            } else if ($type == "string") {
                string $supportedSelectionTypes[] = {"vertex", "face", "edge", "uv"};
                string $supportedStringTypes[] = {"info"};

                string $selectionType = "";
                int $selectionIndex = -1;
                int $treatAsSelection = false;

                string $stringType = "";

                // See if we need to handle this string parm differently
                for ($category in $categories) {
                    string $prefixSelection = "hapiParmSelect_";
                    string $prefixString = "hapiParmString_";

                    if (startsWith($category, $prefixSelection)) {
                        $selectionType = stringRemovePrefix($category, $prefixSelection);
                        $selectionIndex = stringArrayFind($selectionType, 0, $supportedSelectionTypes);

                        if ($selectionIndex >= 0) {
                            $treatAsSelection = true;
                            // We don't support multiple selection types, so bail out here.
                            break;
                        }
                    } else if (startsWith($category, $prefixString)) {
                        $stringType = stringRemovePrefix($category, $prefixString);
                        break;
                    }
                }

                if ($treatAsSelection == true) {
                    createPrimSelectionParm($plug, $niceName, $isEnabled, $parmHelp, $selectionType, $selectionIndex);

                } else {
                    createStringParm($plug, ($nodeName + "." + $child), $niceName, $isEnabled, $parmHelp, $parmName, $stringType);
                }
            } else {
                attrControlGrp 
                    -attribute $plug
                    -annotation $parmHelp
                    -enable $isEnabled;
            }

        } else if($isCompound && !$isMulti) {
            int $collapsed = 0;

            for ($category in $categories) 
            {
                if ($category == "default_close")
                {
                    $collapsed = 1;
                }
            }
          
            float $color = 0.23;

            if (`match "__lv1__" $parmName` == "__lv1__") {
                $color = 0.26;
            }

            separator -height 2 -style "none" -backgroundColor 0.285 0.285 0.285;

            frameLayout
                -collapsable true
                -collapse $collapsed
                -label $niceName
                -backgroundColor $color $color $color
                -font "plainLabelFont";

                columnLayout
                    -adjustableColumn true;

                    buildAttrTree($nodeName, $child, $fullAttr + "." + $child);

                    setParent ..;
                setParent ..;

        } else if($isCompound && $isMulti && $isRamp) {
            createRampParm(($nodeName + "." + $child), $niceName);
            
        } else if($isCompound && $isMulti && !$isRamp) {
            // a multiparm is represented by a "multiSize" attribute and a multi compound attribute
            // the actual UI for the multiparm attribute is generated when checking "multiSize"
        } else if($isMultiSize) {
            createMultiParm($plug, $child, $multiparm_suffix, $fullAttr, $nodeName, $parmHelp);
            
        } else {
            buildAttrTree($nodeName, $child, $fullAttr + "." + $child);
        }
        
        for ($category in $categories) {
            if ($category == "hapiParm_affectsOthers") {
                // force a full attribute sync whenever this attribute changes
                scriptJob -parent `setParent -q`
                          -attributeChange $plug
                          ("houdiniEngine_syncAssetAttributes " + $nodeName + ";");
            }

            if ($category == "hapiParm_syncsAsset") {
                // force a full asset sync whenever this attribute changes
                scriptJob -parent `setParent -q`
                          -attributeChange $plug
                          ("houdiniEngine_syncAssetOutput " + $nodeName + ";");
            }
        }
    }
}

proc createAttrCheckBox(string $checkBox, string $label, string $annotation) {
    checkBox
        -label $label
        -annotation $annotation
        $checkBox;
}

proc replaceAttrCheckBox(string $checkBox, string $plug, string $changeCommand) {
    checkBox -e
        -value `getAttr $plug`
        $checkBox;

    // stopping playback will trigger the attributeChange scriptJob, so don't
    // add the changeCommand to the scriptJob
    scriptJob
        -parent $checkBox
        -replacePrevious
        -attributeChange $plug
        ("checkBox -e -value `getAttr " + $plug + "`"
         + " \"" + $checkBox + "\";");
    checkBox -e
        -changeCommand ("setAttr " + $plug
                + " `checkBox -q -value \"" + $checkBox + "\"`;"
                + $changeCommand)
        $checkBox;
}

global proc houdiniAssetAdjustMulti(string $parent, string $nodeName, string $attr, string $fullAttr) {
    setParent $parent;

    setUITemplate -pushTemplate attributeEditorTemplate;

    string $fullAttrName = $nodeName + "." + $fullAttr;

    int $curMultiSize = (`layout -q -numberOfChildren $parent` - 1);
    int $multiSize = `getAttr ($fullAttrName + "__multiSize")`;

    if(attributeExists($attr, $nodeName)) {
        for($i = $curMultiSize; $i < $multiSize; $i++) {
            // Wrap UI for each instance under one layout so that we have a known
            // number of children.
            columnLayout
                -columnAttach "left" 22
                -adjustableColumn true;
                //-rowSpacing 2;

                string $elementAttr = $fullAttr + "[" + $i + "]";

                buildAttrTree($nodeName, $attr, $elementAttr);

                setParent ..;
        }
    } else if ($multiSize > 0) {
        houdiniEngine_syncAssetAttributes($nodeName);
    }

    string $layoutChildArray[] = `layout -q -childArray $parent`;
    for($i = $curMultiSize; $i-- > $multiSize;) {
        deleteUI $layoutChildArray[$i + 1];
    }

    setUITemplate -popTemplate;
}

global proc AEhoudiniAssetSyncCommandsNew(string $attr) {
    setUITemplate -pushTemplate NONE;

    columnLayout
        -adjustableColumn 1;

        rowLayout
            -numberOfColumns 3
            -adjustableColumn 2
            -columnAttach 1 both 0
            -columnAttach 2 both 3
            -columnAttach 3 both 0
            -columnAlign 1 center
            -columnAlign 2 center
            -columnAlign 3 center
            -columnWidth3 148 148 148;
        
            iconTextButton -style "textOnly" //-image "sync_asset_24.png"
                -label "Sync Asset" 
                -h 27 -backgroundColor 0.36 0.36 0.36 -mw 3
                -annotation "Recreate all the attributes and output nodes of this asset."
                syncButton;

            iconTextButton -style "textOnly" //-image "sync_asset_24.png" 
                -label "Sync Attributes" 
                -h 27 -backgroundColor 0.36 0.36 0.36 -mw 3
                -annotation "Recreate only attributes of this asset."
                syncAttribsButton;

            iconTextButton -style "textOnly" //-image "sync_asset_24.png"
                -label "Sync Outputs" 
                -h 27 -backgroundColor 0.36 0.36 0.36 -mw 3
                -annotation "Recreate only output nodes of this asset."
                syncOutputsButton;
        
            setParent ..;
        setParent ..;

    setUITemplate -popTemplate;

    AEhoudiniAssetSyncCommandsReplace $attr;
}

global proc AEhoudiniAssetSyncCommandsReplace(string $attr) {
    string $nodeName = plugNode($attr);

    iconTextButton -e 
        -command ("houdiniAsset -sync " + $nodeName)
        syncButton;

    iconTextButton -e 
        -command ("houdiniAsset -sync " + $nodeName + " -syncAttributes")
        syncAttribsButton;

    iconTextButton -e 
        -command ("houdiniAsset -sync " + $nodeName + " -syncOutputs")
        syncOutputsButton;
}

global proc AEhoudiniAssetReloadCommandsNew(string $attr) {
    setUITemplate -pushTemplate NONE;

    columnLayout
        -adjustableColumn 1;

        rowLayout
            -numberOfColumns 3
            -adjustableColumn 2
            -columnAttach 1 both 0
            -columnAttach 2 both 3
            -columnAttach 3 both 0
            -columnAlign 1 center
            -columnAlign 2 center
            -columnAlign 3 center
            -columnWidth3 148 148 148;
        
            iconTextButton -style "textOnly" //-image "reload_asset_24.png"
                -label "Reload Asset" 
                -h 27 -backgroundColor 0.36 0.36 0.36 -mw 3
                -annotation "Reload the asset definition for this asset.\nNote that other nodes using the same asset definition will not update until forced to cook (and then sync)."
                reloadButton;

            iconTextButton -style "textOnly" //-image "sync_asset_24.png" 
                -label "Reload without Syncing" 
                -h 27 -backgroundColor 0.36 0.36 0.36 -mw 3
                -annotation "Reload the asset definition for the this asset, but do not sync the asset after reloading.\nIf you know that the asset has the same number and types of outputs as before, this avoids deleting and rebuilding the output shapes in Maya, and any downstream modifications to the outputs will be preserved."
                reloadNoSyncButton;

            iconTextButton -style "textOnly" //-image "reload_asset_24.png"
                -label "Bake Asset" 
                -h 27 -backgroundColor 0.36 0.36 0.36 -mw 3
                -annotation "Sync the selected asset, then tear off a copy of its output nodes."
                bakeButton;
        
            setParent ..;
        setParent ..;

    setUITemplate -popTemplate;

    AEhoudiniAssetReloadCommandsReplace $attr;
}

global proc AEhoudiniAssetReloadCommandsReplace(string $attr) {
    string $nodeName = plugNode($attr);

    iconTextButton -e 
        -command ("houdiniAsset -reloadAsset " + $nodeName)
        reloadButton;

    iconTextButton -e 
        -command ("houdiniAsset -reloadNoSync " + $nodeName)
        reloadNoSyncButton;

    iconTextButton -e 
        -command ("houdiniEngine_bakeAsset " + $nodeName)
        bakeButton;
}

global proc AEhoudiniAssetSetInputToSelection(string $inputAttr) {
    string $objects[] = `ls -selection -long`;

    // make sure we don't include the houdiniAsset node itself if it's selected last
    if(size($objects)) {
        int $lastSelectionIndex = size($objects) - 1;
        string $node[];
        $node[0] = plugNode($inputAttr);
        $node = `ls -long $node[0]`;
        if($node[0] == $objects[$lastSelectionIndex]) {
            stringArrayRemoveAtIndex($lastSelectionIndex, $objects);
        }
    }

    if(!houdiniEngine_setAssetInput($inputAttr, $objects)) {
        error("Cannot set input.");
    }
}

global proc AEhoudiniAssetSetInputToText(string $textField, string $inputAttr) {
    string $objects[] = stringToStringArray(`textFieldGrp -q -text $textField`, " ");

    if(!houdiniEngine_setAssetInput($inputAttr, $objects)) {
        error("Cannot set input.");
    }
}

global proc AEhoudiniAssetInputsNew(string $inputsAttribute) {
    columnLayout -adj true "inputsLayout";
    setParent ..;

    AEhoudiniAssetInputsReplace $inputsAttribute;
}

global proc AEhoudiniAssetInputsReplace(string $inputsAttribute) {
    string $parent = `setParent -q`;
    string $inputsLayoutFull = $parent + "|inputsLayout";

    if(`layout -q -numberOfChildren $inputsLayoutFull`)
    {
        for($child in `layout -q -childArray $inputsLayoutFull`)
        {
            deleteUI ($inputsLayoutFull + "|" + $child);
        }
    }

    setParent $inputsLayoutFull;

    int $multiIndices[] = `getAttr -multiIndices $inputsAttribute`;
    for($i=0; $i < size($multiIndices); $i++)
    {
        int $index = $multiIndices[$i];
        string $inputAttribute = $inputsAttribute + "[" + $index + "]";

        string $inputName = `getAttr ($inputAttribute + ".inputName")`;

        createInputWidget($inputAttribute + ".inputNodeId", $inputName);

        if($i < size($multiIndices) - 1)
        {
            separator -height 12 -style "in";
        }
    }

    setParent ..;
}

global proc AEhoudiniAssetUpdateInput(string $inputLayout, string $inputAttribute) {
    string $inputTextField = $inputLayout + "|inputTextField";

    string $inputGeometryNodes[] = houdiniEngine_getAssetInput($inputAttribute);

    textFieldGrp -e 
        -text (stringArrayToString($inputGeometryNodes, " "))
        $inputTextField;
}

global proc AEhoudiniAssetParmNew(string $houdiniAssetParmAttribute) {
    columnLayout -adjustableColumn 1 
        //-rowSpacing 2
        "parmLayout";

    setParent ..;

    AEhoudiniAssetParmReplace $houdiniAssetParmAttribute;
}

global proc AEhoudiniAssetParmReplace(string $houdiniAssetParmAttribute) {
    string $parent = `setParent -q`;
    string $parmLayoutFull = $parent + "|parmLayout";

    if(`layout -q -numberOfChildren $parmLayoutFull`)
    {
        for($child in `layout -q -childArray $parmLayoutFull`)
        {
            deleteUI ($parmLayoutFull + "|" + $child);
        }
    }

    setParent $parmLayoutFull;

    string $nodeName = plugNode($houdiniAssetParmAttribute);
    string $attrName = plugAttr($houdiniAssetParmAttribute);

    if(attributeExists($attrName, $nodeName)) {
        buildAttrTree($nodeName, $attrName, $attrName);
    }
}

global proc AEhoudiniAssetShowCookMessages(string $nodeName) {
    string $cookMessages = `houdiniAsset -cookMessages $nodeName`;

    string $window = "houdiniAssetShowCookMessages";
    if(`window -exists $window`)
    {
        deleteUI -window $window;
    }

    window
        -title ($nodeName + ": Cook Messages")
        $window;
    string $formLayout = `formLayout`;
    string $cookMessagesField = `scrollField -editable false -text $cookMessages`;
    string $closeButton = `button
        -label "Close"
        -command ("deleteUI -window " + $window)`;

    formLayout -e
        -attachForm $cookMessagesField "top" 0
        -attachForm $cookMessagesField "left" 0
        -attachForm $cookMessagesField "right" 0
        -attachControl $cookMessagesField "bottom" 0 $closeButton

        -attachNone $closeButton "top"
        -attachForm $closeButton "left" 0
        -attachForm $closeButton "right" 0
        -attachForm $closeButton "bottom" 0

        $formLayout;

    showWindow $window;
}

global proc AEhoudiniAssetOptionsNew(string $attr) {
    global int $gAttributeEditorTemplateLabelWidthCustom;

    columnLayout
        -adjustableColumn true
        optionsLayout;

        columnLayout
            -columnAttach "left" $gAttributeEditorTemplateLabelWidthCustom 
            //-rowSpacing 2
            outputLayout;
        
            createAttrCheckBox("splitGeosByGroup", "Split Geos By Group",
                    "Split geos by group.");

            createAttrCheckBox("outputGeometryGroups", "Output Geometry Groups",
                    "Output geometry groups.");

            separator -height 12 -style "in";

            createAttrCheckBox("outputMeshPreserveHardEdges", "Preserve mesh hard edges (possibly slow)",
                    "Preserve hard edges when outputting mesh.");

            createAttrCheckBox("outputMeshPreserveLockedNormals", "Preserve mesh locked normals (possibly slow)",
                    "Preserve locked normals when outputting mesh.");
            
            separator -height 12 -style "in";

            createAttrCheckBox("alwaysMergeInputGeometry", "Always Merge Input Geometry",
                    "Always create a merge node when providing geometry to an input.");

            createAttrCheckBox("packBeforeMerge", "Pack Input Geometry Before Merge",
                    "Pack geometry before merging them together.");

            separator -height 12 -style "in";

            createAttrCheckBox("syncWhenInputConnects", "Sync When Input Connects",
                    "Sync the output nodes when an input is connected.");

            createAttrCheckBox("autoSyncOutputs", "Auto Sync Outputs",
                    "Attemps to automatically sync the output nodes when necessary.");

            separator -height 12 -style "in";

            createAttrCheckBox("useAssetObjectTransform", "Use Asset Object Transform",
                    "Use asset's object-level transform, if exists.");

            createAttrCheckBox("outputHiddenObjects", "Output Hidden Objects",
                    "Output hidden objects.");

            createAttrCheckBox("outputTemplatedGeometries", "Output Templated Geometries",
                    "Output templated geometries.");

            createAttrCheckBox("outputCustomAttributes", "Output Custom Attributes",
                    "Output custom attributes.");

            createAttrCheckBox("ungroupOnBake", "Ungroup On Bake",
                    "Ungroup baked items from mid-level transform.");

            createAttrCheckBox("useInstancerNode", "Use Instancer Node",
                    "Use particle instancer node to output instances.");

            createAttrCheckBox("updateParmsForEvalMode", "Update Parms for Eval Mode",
                    "When evaluation mode is Serial or Parallel, update animated parms.");

            createAttrCheckBox("connectGeoForAssetInputs", "Connect Geo For Asset Inputs",
                    "When setting an input to a geo output of another asset, connect through the geo, not directly from the asset.");

            createAttrCheckBox("bakeOutputTextures", "Bake Output Textures",
                    "When an Output Material has a Texture, bake to a file texture. Turn this off to improve performace when the texture is not needed.");

            createAttrCheckBox("preserveScale", "Preserve Houdini Scale",
                    "Interpret HDA Units as centimeters in Maya.");

            separator -height 12 -style "in";

            button 
                -height 27
                -label "Show Cook Messages"
                -annotation "Show the cook messages that were generated from the cook."
                showCookMessagesButton;

            button
                -height 27 
                -label "Reset Simulation"
                -annotation "Resets all the simulation caches."
                resetSimulationButton;

            setParent ..;

        setParent ..;

    AEhoudiniAssetOptionsReplace $attr;
}

global proc AEhoudiniAssetOptionsReplace(string $attr) {
    string $nodeName = plugNode($attr);

    string $parent = `setParent -q`;
    string $optionsLayoutFull = $parent + "|optionsLayout";
    
    // outputLayout
    button -e
        -c ("AEhoudiniAssetShowCookMessages " + $nodeName)
        ($optionsLayoutFull + "|outputLayout|showCookMessagesButton");
    button -e
        -c ("houdiniAsset -resetSimulation " + $nodeName)
        ($optionsLayoutFull + "|outputLayout|resetSimulationButton");

    replaceAttrCheckBox($optionsLayoutFull + "|outputLayout|syncWhenInputConnects",
            $nodeName + ".syncWhenInputConnects",
            "");
    replaceAttrCheckBox($optionsLayoutFull + "|outputLayout|autoSyncOutputs",
            $nodeName + ".autoSyncOutputs",
            "houdiniEngine_syncAssetOutput \"" + $nodeName + "\";");
    replaceAttrCheckBox(
            $optionsLayoutFull + "|outputLayout|useAssetObjectTransform",
            $nodeName + ".useAssetObjectTransform",
            "houdiniEngine_syncAssetOutput \"" + $nodeName + "\";");
    replaceAttrCheckBox($optionsLayoutFull + "|outputLayout|splitGeosByGroup",
            $nodeName + ".splitGeosByGroup",
            "houdiniEngine_syncAssetOutput \"" + $nodeName + "\";");
    replaceAttrCheckBox($optionsLayoutFull + "|outputLayout|outputHiddenObjects",
            $nodeName + ".outputHiddenObjects",
            "houdiniEngine_syncAssetOutput \"" + $nodeName + "\";");
    replaceAttrCheckBox(
            $optionsLayoutFull + "|outputLayout|outputTemplatedGeometries",
            $nodeName + ".outputTemplatedGeometries",
            "houdiniEngine_syncAssetOutput \"" + $nodeName + "\";");
    replaceAttrCheckBox(
            $optionsLayoutFull + "|outputLayout|outputGeometryGroups",
            $nodeName + ".outputGeometryGroups",
            "houdiniEngine_syncAssetOutput \"" + $nodeName + "\";");
    replaceAttrCheckBox(
            $optionsLayoutFull + "|outputLayout|outputCustomAttributes",
            $nodeName + ".outputCustomAttributes",
            "houdiniEngine_syncAssetOutput \"" + $nodeName + "\";");
    replaceAttrCheckBox(
            $optionsLayoutFull + "|outputLayout|outputMeshPreserveHardEdges",
            $nodeName + ".outputMeshPreserveHardEdges",
            "");
    replaceAttrCheckBox(
            $optionsLayoutFull + "|outputLayout|outputMeshPreserveLockedNormals",
            $nodeName + ".outputMeshPreserveLockedNormals",
            "");
    replaceAttrCheckBox(
            $optionsLayoutFull + "|outputLayout|ungroupOnBake",
            $nodeName + ".ungroupOnBake",
            "");
    replaceAttrCheckBox(
            $optionsLayoutFull + "|outputLayout|updateParmsForEvalMode",
            $nodeName + ".updateParmsForEvalMode",
            "");
    replaceAttrCheckBox(
            $optionsLayoutFull + "|outputLayout|connectGeoForAssetInputs",
            $nodeName + ".connectGeoForAssetInputs",
            "");
    replaceAttrCheckBox(
            $optionsLayoutFull + "|outputLayout|bakeOutputTextures",
            $nodeName + ".bakeOutputTextures",
            "");
    replaceAttrCheckBox($optionsLayoutFull + "|outputLayout|useInstancerNode",
            $nodeName + ".useInstancerNode",
            "houdiniEngine_syncAssetOutput \"" + $nodeName + "\";");
    replaceAttrCheckBox($optionsLayoutFull + "|outputLayout|preserveScale",
            $nodeName + ".preserveScale",
            "houdiniEngine_preserveHoudiniScaleChanged \"" + $nodeName + "\";");
    replaceAttrCheckBox($optionsLayoutFull + "|outputLayout|alwaysMergeInputGeometry",
            $nodeName + ".alwaysMergeInputGeometry",
            "houdiniEngine_alwaysMergeInputGeometryChanged \"" + $nodeName + "\";");
    replaceAttrCheckBox($optionsLayoutFull + "|outputLayout|packBeforeMerge",
            $nodeName + ".packBeforeMerge",
            "houdiniEngine_packBeforeMergeChanged \"" + $nodeName + "\";");
}

global proc AEhoudiniAssetConnectNew( string $attrName ) {
    setUITemplate -pst attributeEditorTemplate;
    attrEnumOptionMenuGrp -attribute $attrName
        -enumeratedItem 0 "Classic Asset"
        -enumeratedItem 1 "History Asset"
        -enumeratedItem 2 "Bake Asset"
        -label "Connect Type" AEhoudiniAssetConnectEnum;
    setUITemplate -ppt;

    AEhoudiniAssetConnectReplace $attrName;
}

global proc AEhoudiniAssetConnectReplace( string $attrName ) {
    attrEnumOptionMenuGrp -e 
        -attribute $attrName 
        AEhoudiniAssetConnectEnum;
}

proc handleAssetHelpSection( string $nodeName ) {
    string $plugNode = `plugNode($nodeName)`;
    int $hasHelpURL  = size(`getAttr($plugNode + ".assetHelpURL")`) > 0;
    int $hasHelpText = size(`getAttr($plugNode + ".assetHelpText")`) > 0;

    // set visibility
    button      -e -visible $hasHelpURL AEhoudiniAssetHelpURLBtn;
    scrollField -e -visible $hasHelpText AEhoudiniAssetHelpTextField;
    text        -e -visible (!$hasHelpURL && !$hasHelpText) AEhoudiniAssetHelpEmptyLabel;

    // set values
    if ($hasHelpURL)
        button -e -command ("launch -web \"" + getAttr($plugNode + ".assetHelpURL") + "\";") AEhoudiniAssetHelpURLBtn;
    else if ($hasHelpText)
        scrollField -e -text `getAttr($plugNode + ".assetHelpText")` AEhoudiniAssetHelpTextField;
}

global proc AEhoudiniAssetHelpNew( string $nodeName ) {
    button      -label "Open Help" AEhoudiniAssetHelpURLBtn;
    scrollField -editable false AEhoudiniAssetHelpTextField;
    text        -align "center" -label "No Help Found" AEhoudiniAssetHelpEmptyLabel;

    handleAssetHelpSection($nodeName);
}

global proc AEhoudiniAssetHelpReplace( string $nodeName ) {
    handleAssetHelpSection($nodeName);
}

proc handleAssetPathSection( string $nodeName ) {
    string $directory = `python "import os; pathdir = os.path.expandvars(\"%PRISM_PROJECT_PATH%\"); pathdir"`;

    string $plugNode = `plugNode($nodeName)`;
    string $filePath = `getAttr ($plugNode + ".otlFilePath")`;

    string $filePathAbsolute = `substitute "%PRISM_PROJECT_PATH%" $filePath $directory`;

    textFieldGrp -e -text $filePathAbsolute AEhoudiniAssetPathText;
}

global proc AEhoudiniAssetPathNew( string $nodeName ) {
    textFieldGrp
        -label "File Path"
        -text "" 
        AEhoudiniAssetPathText;

    handleAssetPathSection($nodeName);
}

global proc AEhoudiniAssetPathReplace( string $nodeName ) {
    handleAssetPathSection($nodeName);
}

global proc AEhoudiniAssetTemplate(string $nodeName) {
    editorTemplate -beginLayout "Houdini Engine Commands";
        editorTemplate -beginLayout "Sync Commands" -collapse false;
            editorTemplate -callCustom "AEhoudiniAssetSyncCommandsNew" "AEhoudiniAssetSyncCommandsReplace"
        "unused";
        editorTemplate -endLayout;

        editorTemplate -beginLayout "Reload and Bake Commands";
            editorTemplate -callCustom "AEhoudiniAssetReloadCommandsNew" "AEhoudiniAssetReloadCommandsReplace"
        "unused";
        editorTemplate -endLayout;
    editorTemplate -endLayout;

    editorTemplate -beginScrollLayout;
    
        editorTemplate -beginLayout "Asset Parameters" -collapse false;
            editorTemplate -callCustom "AEhoudiniAssetParmNew" "AEhoudiniAssetParmReplace" "houdiniAssetParm";
        editorTemplate -endLayout;

        editorTemplate -beginLayout "Asset Help" -collapse true;
            editorTemplate -callCustom "AEhoudiniAssetHelpNew" "AEhoudiniAssetHelpReplace" $nodeName;
        editorTemplate -endLayout;

        editorTemplate -beginLayout "Asset Information";

            editorTemplate
                -label "Asset Type"
                -addControl "assetName";
            editorTemplate -callCustom "AEhoudiniAssetPathNew" "AEhoudiniAssetPathReplace" $nodeName;
                //-label "File Path"
                //-addControl "otlFilePath";

            editorTemplate -beginLayout "Asset State" -collapse true;
                editorTemplate -callCustom "AEhoudiniAssetConnectNew" "AEhoudiniAssetConnectReplace" "assetConnectType";
                editorTemplate
                    -label "Frozen"
                    -addControl "frozen";
            editorTemplate -endLayout;

        editorTemplate -endLayout;

        editorTemplate -beginLayout "Asset Options" -collapse true;

            editorTemplate -callCustom "AEhoudiniAssetOptionsNew" "AEhoudiniAssetOptionsReplace" "unused";
            editorTemplate -beginLayout "Asset Callbacks" -collapse true;
                editorTemplate
                    -label "Pre Sync Callback"
                    -addControl "preSyncCallback";

                editorTemplate
                    -label "Post Sync Callback"
                    -addControl "postSyncCallback";

            editorTemplate -endLayout;

            editorTemplate -suppress "syncWhenInputConnects";
            editorTemplate -suppress "autoSyncOutputs";

            editorTemplate -suppress "useAssetObjectTransform";
            editorTemplate -suppress "splitGeosByGroup";
            editorTemplate -suppress "outputHiddenObjects";
            editorTemplate -suppress "outputTemplatedGeometries";
            editorTemplate -suppress "outputGeometryGroups";
            editorTemplate -suppress "outputCustomAttributes";
            editorTemplate -suppress "outputMeshPreserveHardEdges";
            editorTemplate -suppress "outputMeshPreserveLockedNormals";
            editorTemplate -suppress "output";
            editorTemplate -suppress "ungroupOnBake";
            editorTemplate -suppress "updateParmsForEvalMode";
            editorTemplate -suppress "bakeOutputTextures";
            editorTemplate -suppress "preserveScale";
            editorTemplate -suppress "connectGeoForAssetInputs";
            editorTemplate -suppress "alwaysMergeInputGeometry";
            editorTemplate -suppress "packBeforeMerge";

            editorTemplate -suppress "useInstancerNode";
            editorTemplate -suppress "cachedSrcAttr";
            editorTemplate -suppress "cachedDstAttr";
            editorTemplate -suppress "cachedDstNode";

        editorTemplate -endLayout;

        editorTemplate -beginLayout "Maya Transform Attributes";

            AEtransformMain $nodeName;
            AEtransformNoScroll $nodeName;

        editorTemplate -endLayout;

        editorTemplate -addExtraControls;
    editorTemplate -endLayout;
}